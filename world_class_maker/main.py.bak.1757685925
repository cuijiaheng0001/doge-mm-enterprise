"""
World Class Market Maker - ä¸–ç•Œçº§åšå¸‚å•†ä¸»æ§åˆ¶å™¨
é›†æˆ5å±‚10ç»„ä»¶çš„å®Œæ•´è§£å†³æ–¹æ¡ˆï¼Œå¯¹æ ‡Jane Street/Citadelæ ‡å‡†
"""
import asyncio
import time
import logging
import os
import sys
from decimal import Decimal
from typing import Dict, Any, Optional, List
from dotenv import load_dotenv

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°è·¯å¾„
sys.path.append('/home/ubuntu')

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv('/home/ubuntu/.env.golden')

# é…ç½®æ—¥å¿— (å¿…é¡»åœ¨å¯¼å…¥EventNormalizerå‰)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

from doge_mm.packages.risk.institutional_event_ledger import InstitutionalEventLedger
from doge_mm.packages.risk.pessimistic_reservation_model import PessimisticReservationModel
from doge_mm.packages.utils.dual_active_market_data import DualActiveMarketData, TickerData
from doge_mm.packages.risk.shadow_balance_v2 import InstitutionalShadowBalance

# å¯¼å…¥SSOTé¢„æ‰£é—­ç¯
from doge_mm.packages.exec.order_response_handler import SSOTReservationClosedLoop
# ç¦ç”¨Mockå¼•æ“ï¼Œä½¿ç”¨çœŸå®è¿æ¥å™¨
from doge_mm.packages.exec.order_execution_engine import OrderRequest  # ä¿ç•™OrderRequestç±»
from doge_mm.packages.connectors.turbo_connector_v2 import TurboConnectorV2
from dataclasses import dataclass

# å¯¼å…¥æµåŠ¨æ€§åŒ…ç»œ (Phase 6 æ­¥éª¤3)
from doge_mm.packages.utils.liquidity_envelope import LiquidityEnvelope, OrderLevel
from doge_mm.packages.exec.smart_order_system import SmartOrderSystem, MarketSnapshot, OrderLevel as SmartOrderLevel

# å¯¼å…¥æ¯«ç§’å“åº”ç³»ç»Ÿ (Phase 6 æ­¥éª¤5)
from doge_mm.packages.exec.millisecond_response_system import get_millisecond_response_system, OrderLevel as ResponseOrderLevel

# å¯¼å…¥åº“å­˜ç®¡ç†ä¸‰æ—¶åŸŸç³»ç»Ÿ (Phase 6 æ­¥éª¤6)
from doge_mm.packages.exec.three_domain_inventory_system import get_three_domain_inventory_system

# å¯¼å…¥å¯è§‚æµ‹æ€§ä»ªè¡¨ç›˜ (Phase 6 æ­¥éª¤7)
from doge_mm.packages.utils.observability_dashboard import get_observability_dashboard, AlertLevel

# å®‰å…¨å¯¼å…¥EventNormalizer + è¦†ç›–ç‡æŒ‡æ ‡
try:
    from doge_mm.packages.connectors.event_normalizer import EventNormalizer
    HAVE_NORMALIZER = True
    NORMALIZER_COVERAGE = 0.0  # å°†åœ¨è¿è¡Œæ—¶æ›´æ–°
    logger.info("[WorldClassMaker] EventNormalizer imported successfully")
except ImportError as e:
    HAVE_NORMALIZER = False
    NORMALIZER_COVERAGE = 0.0
    EventNormalizer = None
    logger.warning("[WorldClassMaker] EventNormalizer import failed: %s", str(e))


class WorldClassMarketMaker:
    """
    ä¸–ç•Œçº§åšå¸‚å•†ä¸»æ§åˆ¶å™¨
    
    5å±‚æ¶æ„ï¼š
    1. èµ„é‡‘ç®¡ç†ï¼šSSOTäº‹ä»¶è´¦æœ¬ + æ‚²è§‚é¢„æ‰£æ¨¡å‹
    2. è¡Œæƒ…æ•°æ®ï¼šåŒæ´»å¸‚åœºæ•°æ®æº + å¾®è§‚ç»“æ„å®šä»·  
    3. æµåŠ¨æ€§ä¿éšœï¼šæµåŠ¨æ€§åŒ…ç»œ + é˜Ÿåˆ—ä½ç½®ä¼°ç®—
    4. è®¢å•ç®¡ç†ï¼šå±å®³ç‡é©±åŠ¨åˆ‡ç‰‡ + ä¸‰åŸŸåº“å­˜æ§åˆ¶
    5. æ‰§è¡Œç®¡é“ï¼šäº‹ä»¶é©±åŠ¨ + 8æŒ‡æ ‡å¯è§‚æµ‹æ€§
    """
    
    def __init__(self):
        # === ç¬¬1å±‚ï¼šèµ„é‡‘ç®¡ç† ===
        self.event_ledger = InstitutionalEventLedger()
        self.reservation_model = PessimisticReservationModel({
            'DOGE': 0.05,  # 5% é¢„ç•™
            'USDT': 0.05   # 5% é¢„ç•™
        })
        
        # SSOTé¢„æ‰£é—­ç¯ï¼ˆPhase 6 æ­¥éª¤2ï¼‰
        self.reservation_closed_loop = SSOTReservationClosedLoop(
            self.reservation_model,
            timeout_seconds=30
        )
        
        # ä½¿ç”¨çœŸå®äº¤æ˜“è¿æ¥å™¨
        self.turbo_connector = TurboConnectorV2(
            api_key=os.getenv('API_KEY'),
            api_secret=os.getenv('API_SECRET')
        )
        # åˆ›å»ºé€‚é…å™¨å¯¹è±¡
        self.order_engine = self  # ä½¿ç”¨selfä½œä¸ºé€‚é…å™¨
        
        # === ç¬¬2å±‚ï¼šè¡Œæƒ…æ•°æ® ===
        self.market_data = DualActiveMarketData("DOGEUSDT", latency_threshold_ms=10)
        # self.pricer = MicrostructurePricer()  # æš‚æ—¶æ³¨é‡Šï¼Œç®€åŒ–å®ç°
        
        # === ç¬¬3å±‚ï¼šæµåŠ¨æ€§ä¿éšœ ===
        # Phase 6 æ­¥éª¤3: æµåŠ¨æ€§åŒ…ç»œç³»ç»Ÿ
        self.liquidity_envelope = LiquidityEnvelope(
            alpha=0.10,           # 10%æƒç›Šé…ç½®
            min_l0_slots=8,       # L0æœ€å°8æ§½ä½
            max_l0_slots=15,      # L0æœ€å¤§15æ§½ä½
            spread_sensitivity=2.0
        )
        
        # === ç¬¬4å±‚ï¼šæ™ºèƒ½ä¸‹å• ===
        # Phase 6 æ­¥éª¤4: æ™ºèƒ½ä¸‹å•ç³»ç»Ÿ (QPE + ä¸‰é‡ä¸Šé™ + å¾®æ‰¹æ»´çŒ + PriceGuard)
        self.smart_order_system = SmartOrderSystem()
        
        # === ç¬¬5å±‚ï¼šæ¯«ç§’å“åº” ===
        # Phase 6 æ­¥éª¤5: æ¯«ç§’å“åº”ç³»ç»Ÿ (fillâ†’repostäº‹ä»¶ä¼˜å…ˆçº§ + TTLæ’¤æ¢)
        self.millisecond_response = get_millisecond_response_system()
        
        # === ç¬¬6å±‚ï¼šåº“å­˜ç®¡ç† ===
        # Phase 6 æ­¥éª¤6: åº“å­˜ç®¡ç†ä¸‰æ—¶åŸŸç³»ç»Ÿ (æ¯«ç§’è¡¥ä½/ç§’çº§å€¾æ–œ/çº¯Makerç§¯æTWAP)
        self.inventory_system = get_three_domain_inventory_system()
        
        # === ç¬¬7å±‚ï¼šå¯è§‚æµ‹æ€§ ===
        # Phase 6 æ­¥éª¤7: å¯è§‚æµ‹æ€§ä»ªè¡¨ç›˜ (8æŒ‡æ ‡å‡ºé½ï¼Œè®¾çº¢çº¿ä¸è‡ªä¿ç­–ç•¥)
        self.dashboard = get_observability_dashboard()
        
        # === ç¬¬8å±‚ï¼šè®¢å•ç®¡ç† ===
        # self.order_slicer = HarmRateDrivenSlicer()  # æš‚æ—¶æ³¨é‡Š
        # self.inventory_control = ThreeDomainInventoryControl()  # æš‚æ—¶æ³¨é‡Š
        
        # === ç¬¬9å±‚ï¼šæ‰§è¡Œç®¡é“ ===
        # self.execution_pipeline = EventDrivenExecutionPipeline()  # æš‚æ—¶æ³¨é‡Š
        
        # è¿è¡ŒçŠ¶æ€
        self.running = False
        self.start_time = 0
        
        # æ€§èƒ½æŒ‡æ ‡
        self.metrics = {
            'runtime_seconds': 0,
            'tickers_processed': 0,
            'orders_created': 0,
            'orders_filled': 0,
            'error_rate_2010': 0,
            'avg_latency_ms': 0,
            'current_balance_doge': 0,
            'current_balance_usdt': 0,
            'normalizer_coverage': 0.0,
            'normalizer_events_processed': 0,
            'normalizer_events_fallback': 0
        }
        
        # å­˜å‚¨æœ€æ–°tickeræ•°æ®ç”¨äºä»ªè¡¨ç›˜
        self.latest_ticker = None
        
        # EventNormalizerçŠ¶æ€è·Ÿè¸ª
        self.total_events = 0
        self.normalized_events = 0
        
        # è®¢å•è·Ÿè¸ª - é˜²æ­¢åƒµå°¸è®¢å•
        self.active_orders = {}  # order_id -> {'time': timestamp, 'side': side, 'price': price, 'qty': qty}
        self.last_cleanup_time = 0
        self.cleanup_interval = 30  # æ¯30ç§’æ¸…ç†ä¸€æ¬¡åƒµå°¸è®¢å•
        self.order_ttl = 60  # è®¢å•ç”Ÿå­˜æ—¶é—´60ç§’
        
        # æ™ºèƒ½è®¢å•é‡ç³»ç»Ÿ (IBEE)
        self.base_order_size = 50  # åŸºç¡€è®¢å•é‡
        self.recent_fills = []  # è®°å½•æœ€è¿‘æˆäº¤
        self.last_fill_time = 0
        self.market_volatility = 0.001  # åˆå§‹æ³¢åŠ¨ç‡
        
        logger.info("[WorldClassMaker] åˆå§‹åŒ–å®Œæˆ - ä¸–ç•Œçº§åšå¸‚å•†ç³»ç»Ÿå°±ç»ª")
    
    def get_engine_stats(self):
        """è·å–å¼•æ“ç»Ÿè®¡ä¿¡æ¯"""
        return {
            'orders_created': self.metrics.get('orders_created', 0),
            'orders_filled': self.metrics.get('orders_filled', 0),
            'error_rate': self.metrics.get('error_rate_2010', 0),
            'stats': {
                'orders_submitted': self.metrics.get('orders_created', 0),
                'orders_acked': self.metrics.get('orders_created', 0),
                'orders_rejected': 0,
                'orders_filled': self.metrics.get('orders_filled', 0),
                'orders_canceled': self.metrics.get('orders_canceled', 0),
                'orders_timeout': 0
            }
        }
    
    async def shutdown(self):
        """å…³é—­è®¢å•å¼•æ“"""
        await self._shutdown()
    
    async def initialize_components(self):
        """åˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶"""
        try:
            # åˆå§‹åŒ–TurboConnector
            await self.turbo_connector.initialize()
            
            # åˆå§‹åŒ–å¸‚åœºæ•°æ®
            self.market_data.add_ticker_callback(self._on_ticker_update)
            await self.market_data.start()
            
            # ä½¿ç”¨å›ºå®šä½™é¢è¿›è¡Œæµ‹è¯•
            # TODO: åç»­å®ç°get_account_balanceæ¥å£
            self.reservation_model.update_real_balance('DOGE', Decimal('999.5'))
            self.reservation_model.update_real_balance('USDT', Decimal('94.77'))
            logger.info("[WorldClassMaker] åˆå§‹ä½™é¢ DOGE: 999.5, USDT: 94.77")
            
            # å¯åŠ¨æ¯«ç§’å“åº”ç³»ç»Ÿ (Phase 6 æ­¥éª¤5)
            await self.millisecond_response.start()
            
            logger.info("[WorldClassMaker] æ‰€æœ‰ç»„ä»¶åˆå§‹åŒ–å®Œæˆ")
            return True
            
        except Exception as e:
            logger.error("[WorldClassMaker] ç»„ä»¶åˆå§‹åŒ–å¤±è´¥: %s", str(e))
            return False
    
    async def submit_order(self, order_request: OrderRequest) -> bool:
        """
        é€‚é…æ–¹æ³•ï¼šå°†OrderRequestè½¬æ¢ä¸ºTurboConnectorçš„create_orderè°ƒç”¨
        
        Args:
            order_request: è®¢å•è¯·æ±‚å¯¹è±¡
            
        Returns:
            bool: è®¢å•æ˜¯å¦æˆåŠŸæäº¤
        """
        try:
            # åˆ›å»ºé¢„æ‰£ - ä½¿ç”¨æ­£ç¡®çš„å‚æ•°æ ¼å¼
            success = self.reservation_model.reserve(
                order_id=order_request.order_id,
                side=order_request.side,
                qty=order_request.qty,
                price=order_request.price
            )
            if not success:
                logger.warning("[WorldClassMaker] é¢„æ‰£å¤±è´¥: %s", order_request.order_id)
                return False
            
            # è°ƒç”¨çœŸå®äº¤æ˜“æ¥å£
            result = await self.turbo_connector.create_order(
                symbol=order_request.symbol,
                side=order_request.side,
                order_type='LIMIT',
                quantity=str(order_request.qty),
                price=str(order_request.price),
                timeInForce='GTC',
                clientOrderId=order_request.order_id
            )
            
            # å¤„ç†å“åº”
            if result.get('orderId'):
                # è®¢å•æˆåŠŸï¼Œä¿æŒé¢„æ‰£
                logger.info("[WorldClassMaker] è®¢å•æˆåŠŸ: %s", order_request.order_id)
                
                # è·Ÿè¸ªæ´»è·ƒè®¢å• - é˜²æ­¢åƒµå°¸è®¢å•
                self.active_orders[result['orderId']] = {
                    'time': time.time(),
                    'side': order_request.side,
                    'price': float(order_request.price),
                    'qty': float(order_request.qty),
                    'client_order_id': order_request.order_id
                }
                
                return True
            else:
                # è®¢å•å¤±è´¥ï¼Œé‡Šæ”¾é¢„æ‰£
                self.reservation_model.release_for_order(
                    order_id=order_request.order_id,
                    reason='ORDER_FAILED'
                )
                logger.warning("[WorldClassMaker] è®¢å•å¤±è´¥: %s - %s", 
                              order_request.order_id, result.get('msg', 'Unknown error'))
                return False
                
        except Exception as e:
            logger.error("[WorldClassMaker] è®¢å•æäº¤å¤±è´¥: %s", str(e))
            # é‡Šæ”¾é¢„æ‰£
            try:
                self.reservation_model.release(
                    order_id=order_request.order_id,
                    asset=asset,
                    reserved_amount=amount,
                    released_amount=amount
                )
            except:
                pass
            return False
    
    async def cleanup_zombie_orders(self):
        """æ¸…ç†åƒµå°¸è®¢å• - å®šæœŸæ’¤é”€è¶…æ—¶çš„è®¢å•"""
        current_time = time.time()
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸…ç†
        if current_time - self.last_cleanup_time < self.cleanup_interval:
            return
            
        self.last_cleanup_time = current_time
        
        logger.info("[WorldClassMaker] å¼€å§‹æ¸…ç†åƒµå°¸è®¢å•ï¼Œå½“å‰æ´»è·ƒè®¢å•æ•°: %d", len(self.active_orders))
        
        orders_to_cancel = []
        for order_id, order_info in list(self.active_orders.items()):
            # æ£€æŸ¥è®¢å•æ˜¯å¦è¶…æ—¶
            order_age = current_time - order_info['time']
            if order_age > self.order_ttl:
                orders_to_cancel.append((order_id, order_info))
        
        # æ‰¹é‡æ’¤é”€è¶…æ—¶è®¢å•
        for order_id, order_info in orders_to_cancel:
            try:
                logger.warning("[WorldClassMaker] æ’¤é”€è¶…æ—¶è®¢å•: %s (å¹´é¾„: %.1fç§’)", 
                             order_id, current_time - order_info['time'])
                
                # è°ƒç”¨æ’¤å•API
                result = await self.turbo_connector.cancel_order("DOGEUSDT", int(order_id))
                
                if result.get('status') == 'CANCELED':
                    logger.info("[WorldClassMaker] æˆåŠŸæ’¤é”€è®¢å•: %s", order_id)
                    # é‡Šæ”¾é¢„æ‰£èµ„é‡‘
                    self.reservation_model.release_for_order(
                        order_id=order_info['client_order_id'],
                        reason='ORDER_CANCELED'
                    )
                    self.metrics['orders_canceled'] = self.metrics.get('orders_canceled', 0) + 1
                else:
                    logger.warning("[WorldClassMaker] æ’¤å•å¤±è´¥: %s - %s", 
                                 order_id, result.get('msg', 'Unknown'))
                    
                # æ— è®ºæˆåŠŸä¸å¦ï¼Œéƒ½ä»æ´»è·ƒè®¢å•ä¸­ç§»é™¤
                del self.active_orders[order_id]
                
            except Exception as e:
                logger.error("[WorldClassMaker] æ’¤å•å¼‚å¸¸: %s - %s", order_id, str(e))
                # ä»ç„¶å°è¯•ç§»é™¤è®¢å•
                if order_id in self.active_orders:
                    del self.active_orders[order_id]
        
        if orders_to_cancel:
            logger.info("[WorldClassMaker] æ¸…ç†å®Œæˆï¼Œæ’¤é”€äº† %d ä¸ªåƒµå°¸è®¢å•", len(orders_to_cancel))
    
    async def cancel_all_orders(self):
        """æ’¤é”€æ‰€æœ‰æ´»è·ƒè®¢å• - ç”¨äºå…³é—­æ—¶æ¸…ç†"""
        logger.info("[WorldClassMaker] æ’¤é”€æ‰€æœ‰æ´»è·ƒè®¢å•: %d", len(self.active_orders))
        
        for order_id, order_info in list(self.active_orders.items()):
            try:
                result = await self.turbo_connector.cancel_order("DOGEUSDT", int(order_id))
                logger.info("[WorldClassMaker] æ’¤é”€è®¢å• %s: %s", order_id, result.get('status'))
                
                # é‡Šæ”¾é¢„æ‰£
                self.reservation_model.release_for_order(
                    order_id=order_info['client_order_id'],
                    reason='SHUTDOWN'
                )
            except Exception as e:
                logger.error("[WorldClassMaker] æ’¤å•å¤±è´¥: %s - %s", order_id, str(e))
        
        self.active_orders.clear()
    
    async def _on_order_update(self, order_data: dict):
        """å¤„ç†è®¢å•æ›´æ–°äº‹ä»¶ - ç§»é™¤å·²æˆäº¤æˆ–å·²å–æ¶ˆçš„è®¢å•"""
        try:
            order_id = order_data.get('orderId')
            status = order_data.get('status')
            
            # å¦‚æœè®¢å•å·²æˆäº¤æˆ–å·²å–æ¶ˆï¼Œä»æ´»è·ƒè®¢å•ä¸­ç§»é™¤
            if order_id and status in ['FILLED', 'CANCELED', 'EXPIRED', 'REJECTED']:
                if order_id in self.active_orders:
                    order_info = self.active_orders[order_id]
                    logger.info("[WorldClassMaker] è®¢å•çŠ¶æ€æ›´æ–°: %s -> %s", order_id, status)
                    
                    if status == 'FILLED':
                        self.metrics['orders_filled'] += 1
                        # è®°å½•æˆäº¤ç”¨äºæ™ºèƒ½è®¢å•é‡è®¡ç®—
                        self.recent_fills.append(time.time())
                        # ä¿ç•™æœ€è¿‘100ä¸ªæˆäº¤
                        if len(self.recent_fills) > 100:
                            self.recent_fills.pop(0)
                    
                    # é‡Šæ”¾é¢„æ‰£ï¼ˆå¦‚æœéœ€è¦ï¼‰
                    if status in ['CANCELED', 'EXPIRED', 'REJECTED']:
                        self.reservation_model.release_for_order(
                            order_id=order_info['client_order_id'],
                            reason=f'ORDER_{status}'
                        )
                    
                    # ä»æ´»è·ƒè®¢å•ä¸­ç§»é™¤
                    del self.active_orders[order_id]
                    logger.info("[WorldClassMaker] ç§»é™¤è®¢å•: %s, å‰©ä½™æ´»è·ƒè®¢å•: %d", 
                              order_id, len(self.active_orders))
                    
        except Exception as e:
            logger.error("[WorldClassMaker] å¤„ç†è®¢å•æ›´æ–°å¤±è´¥: %s", str(e))
    
    async def _on_ticker_update(self, ticker: TickerData):
        """å¤„ç†tickeræ•°æ®æ›´æ–°"""
        try:
            # å­˜å‚¨æœ€æ–°tickeræ•°æ®ç”¨äºä»ªè¡¨ç›˜
            self.latest_ticker = ticker
            
            self.metrics['tickers_processed'] += 1
            
            # è®¡ç®—å»¶è¿Ÿ
            latency_ms = (time.time_ns() - ticker.recv_ts) / 1_000_000
            self.metrics['avg_latency_ms'] = latency_ms
            
            # æ›´æ–°ä½™é¢ä¿¡æ¯ï¼ˆæ¨¡æ‹Ÿï¼‰
            doge_balance = self.reservation_model.get_available_balance('DOGE')
            usdt_balance = self.reservation_model.get_available_balance('USDT')
            
            self.metrics['current_balance_doge'] = float(doge_balance)
            self.metrics['current_balance_usdt'] = float(usdt_balance)
            
            # æ›´æ–°EventNormalizerè¦†ç›–ç‡ï¼ˆæ¨¡æ‹Ÿäº‹ä»¶å¤„ç†ï¼‰
            self.update_normalizer_coverage(event_processed=HAVE_NORMALIZER)
            
            # ç”Ÿæˆåšå¸‚æŠ¥ä»·ï¼ˆç®€åŒ–ç‰ˆï¼‰
            await self._generate_quotes(ticker)
            
        except Exception as e:
            logger.error("[WorldClassMaker] Tickerå¤„ç†å¤±è´¥: %s", str(e))
    
    async def _generate_quotes(self, ticker: TickerData):
        """ç”Ÿæˆå¤šå±‚çº§è¿ç»­åšå¸‚æŠ¥ä»·ï¼ˆåŸºäºæµåŠ¨æ€§åŒ…ç»œçš„ä¸–ç•Œçº§å®ç°ï¼‰"""
        try:
            mid = (ticker.bid + ticker.ask) / 2
            market_spread = ticker.ask - ticker.bid
            market_spread_bps = float((market_spread / mid) * 10000)  # å¸‚åœºä»·å·®
            
            # Phase 7.1: ä½¿ç”¨åšå¸‚å•†ç›®æ ‡ä»·å·®ï¼Œè€Œéå¸‚åœºä»·å·® (0.2bp â†’ 3-8bp)
            spread_bps = self._calculate_target_spread(market_spread_bps, mid)
            
            logger.debug(f"[WorldClassMaker] ä»·å·®ä¼˜åŒ–: å¸‚åœº={market_spread_bps:.1f}bp â†’ ç›®æ ‡={spread_bps:.1f}bp")
            
            # è·å–å®æ—¶å¯ç”¨ä½™é¢
            doge_available = self.reservation_model.get_available_balance('DOGE')
            usdt_available = self.reservation_model.get_available_balance('USDT')
            total_equity = doge_available * mid + usdt_available
            
            # Phase 6 æ­¥éª¤3: ä½¿ç”¨æµåŠ¨æ€§åŒ…ç»œè®¡ç®—ç›®æ ‡
            liquidity_snapshot = self.liquidity_envelope.calculate_liquidity_targets(
                total_equity=total_equity,
                doge_balance=doge_available, 
                usdt_balance=usdt_available,
                current_price=mid,
                spread_bps=spread_bps
            )
            
            # æ”¶é›†å½“å‰æ´»è·ƒè®¢å•çŠ¶æ€
            current_orders = await self._get_current_orders_state()
            buy_orders, sell_orders = current_orders['buy'], current_orders['sell']
            
            # æ›´æ–°æµåŠ¨æ€§åŒ…ç»œçŠ¶æ€
            self.liquidity_envelope.update_current_state(buy_orders, sell_orders)
            
            # æ£€æµ‹è¿è§„å¹¶ç”Ÿæˆå†å¹³è¡¡è®¢å•
            violations = self.liquidity_envelope.detect_violations()
            
            if violations:
                logger.info("[WorldClassMaker] ğŸ”„ æµåŠ¨æ€§è¿è§„æ£€æµ‹: %dé¡¹ï¼Œæ‰§è¡Œå†å¹³è¡¡", len(violations))
                for violation in violations:
                    logger.debug("[WorldClassMaker] è¿è§„è¯¦æƒ…: %s", violation)
                
                rebalance_orders = self.liquidity_envelope.generate_rebalance_orders(mid, spread_bps)
                await self._execute_rebalance_orders(rebalance_orders)
                
            # ç»§ç»­æ­£å¸¸çš„è®¢å•ç”Ÿæˆï¼ˆä½†æ”¹ç”¨æµåŠ¨æ€§åŒ…ç»œæŒ‡å¯¼ï¼‰
            target_spread = mid * Decimal(spread_bps) / Decimal(10000)  # ä»bpè½¬æ¢å›ä»·å·®
            await self._generate_envelope_based_orders(liquidity_snapshot, mid, target_spread)
            
            # å®šæœŸæ¸…ç†è¿‡æœŸé¢„ç•™ï¼ˆæ¯100æ¬¡tickeræ›´æ–°æ‰§è¡Œä¸€æ¬¡ï¼‰
            if self.metrics['tickers_processed'] % 100 == 0:
                expired_count = self.reservation_model.cleanup_expired_reservations()
                if expired_count > 0:
                    logger.info(
                        "[WorldClassMaker] ğŸ§¹ æ¸…ç†è¿‡æœŸé¢„ç•™: %dä¸ª", expired_count
                    )
                
                # Phase 6 æ­¥éª¤2: æ¸…ç†å®Œæˆçš„è®¢å•çŠ¶æ€
                closed_loop_cleaned = self.reservation_closed_loop.cleanup_completed_orders()
                if closed_loop_cleaned > 0:
                    logger.info(
                        "[WorldClassMaker] ğŸ§¹ SSOTé—­ç¯æ¸…ç†: %dä¸ªå·²å®Œæˆè®¢å•", closed_loop_cleaned
                    )
                
                # Phase 6 æ­¥éª¤3: è¾“å‡ºæµåŠ¨æ€§åŒ…ç»œå¥åº·åº¦
                envelope_health = self.liquidity_envelope.get_health_metrics()
                logger.info(
                    "[WorldClassMaker] ğŸ“Š æµåŠ¨æ€§å¥åº·åº¦: L0æ§½ä½=%d/%d ç›®æ ‡è¾¾æˆç‡=%.1f%%",
                    envelope_health.get('active_l0_slots', 0),
                    envelope_health.get('min_l0_slots', 8),
                    envelope_health.get('target_achievement_rate', 0.0)
                )
            
        except Exception as e:
            logger.error("[WorldClassMaker] å¤šå±‚çº§æŠ¥ä»·ç”Ÿæˆå¤±è´¥: %s", str(e))
    
    def _calculate_target_spread(self, market_spread_bps: float, mid_price: float) -> float:
        """
        Phase 7.1: è®¡ç®—åšå¸‚å•†ç›®æ ‡ä»·å·® (3-8bpåŠ¨æ€)
        
        Args:
            market_spread_bps: å¸‚åœºçœŸå®ä»·å·®(åŸºç‚¹)
            mid_price: ä¸­é—´ä»·
            
        Returns:
            float: ç›®æ ‡ä»·å·®(åŸºç‚¹)
        """
        # åŸºç¡€ä»·å·®é…ç½® (3-8bpèŒƒå›´)
        base_spread_bp = 4.0  # åŸºç¡€4bp
        min_spread_bp = 3.0   # æœ€å°3bp 
        max_spread_bp = 8.0   # æœ€å¤§8bp
        
        # ç®€å•æ³¢åŠ¨ç‡ä¼°ç®— (åŸºäºtickerå¤„ç†é¢‘ç‡)
        tickers_per_second = self.metrics['tickers_processed'] / max(1, self.metrics['runtime_seconds'])
        volatility_factor = min(2.0, max(0.5, tickers_per_second / 10))  # 0.5-2.0å€æ•°
        
        # åŠ¨æ€ä»·å·®è®¡ç®—
        if volatility_factor < 0.8:  # ä½æ³¢åŠ¨
            target_spread = min_spread_bp  # æ”¶çª„è‡³3bpï¼Œæé«˜æˆäº¤æ¦‚ç‡
        elif volatility_factor > 1.5:  # é«˜æ³¢åŠ¨
            target_spread = max_spread_bp  # æ‰©å¤§è‡³8bpï¼Œå¢åŠ å®‰å…¨è¾¹é™…  
        else:
            # ä¸­ç­‰æ³¢åŠ¨ï¼š4bp + å¾®è°ƒ
            adjustment = (volatility_factor - 1.0) * 2  # -0.4 åˆ° +1.0
            target_spread = base_spread_bp + adjustment
            target_spread = max(min_spread_bp, min(max_spread_bp, target_spread))
        
        # ç¡®ä¿ä¸ä½äºå¸‚åœºä»·å·®ï¼ˆå®‰å…¨æ€§ï¼‰
        target_spread = max(target_spread, market_spread_bps + 0.5)  # è‡³å°‘æ¯”å¸‚åœºä»·å·®é«˜0.5bp
        
        # è®°å½•é¦–æ¬¡ä»·å·®è°ƒæ•´ï¼ˆç”¨äºéªŒè¯ï¼‰
        if not hasattr(self, '_spread_adjustment_logged'):
            logger.info(
                "[WorldClassMaker-Phase7] ğŸ¯ ä»·å·®ä¼˜åŒ–å¯ç”¨: å¸‚åœº=%.1fbp â†’ ç›®æ ‡=%.1fbp (æå‡%.1fx)",
                market_spread_bps, target_spread, target_spread/max(0.1, market_spread_bps)
            )
            self._spread_adjustment_logged = True
            
        return target_spread
    
    async def _get_current_orders_state(self) -> Dict:
        """
        è·å–å½“å‰æ´»è·ƒè®¢å•çŠ¶æ€
        
        Returns:
            Dict: {'buy': [...], 'sell': [...]}
        """
        try:
            # ç®€åŒ–ç‰ˆå®ç°ï¼šåŸºäºå†…å­˜ä¸­çš„è®¢å•çŠ¶æ€ç»Ÿè®¡
            # å®é™…ç”Ÿäº§ç¯å¢ƒåº”è¯¥ä»äº¤æ˜“æ‰€APIè·å–æ´»è·ƒè®¢å•
            
            # ä»SSOTé¢„æ‰£é—­ç¯è·å–æ­£åœ¨è·Ÿè¸ªçš„è®¢å•
            tracked_orders = self.reservation_closed_loop.get_system_health().get('tracked_orders', {})
            
            buy_orders = []
            sell_orders = []
            
            # æŒ‰sideåˆ†ç±»è®¢å•ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”è¯¥æœ‰ä»·æ ¼å±‚çº§ä¿¡æ¯ï¼‰
            for order_id, order_info in tracked_orders.items():
                if order_info.get('side') == 'BUY':
                    buy_orders.append({
                        'order_id': order_id,
                        'side': 'BUY',
                        'qty': order_info.get('qty', 0),
                        'price': order_info.get('price', 0),
                        'level': 'L0'  # ç®€åŒ–ç‰ˆï¼Œé»˜è®¤L0çº§åˆ«
                    })
                elif order_info.get('side') == 'SELL':
                    sell_orders.append({
                        'order_id': order_id,
                        'side': 'SELL', 
                        'qty': order_info.get('qty', 0),
                        'price': order_info.get('price', 0),
                        'level': 'L0'  # ç®€åŒ–ç‰ˆï¼Œé»˜è®¤L0çº§åˆ«
                    })
            
            return {'buy': buy_orders, 'sell': sell_orders}
            
        except Exception as e:
            logger.error("[WorldClassMaker] è·å–å½“å‰è®¢å•çŠ¶æ€å¤±è´¥: %s", str(e))
            return {'buy': [], 'sell': []}
    
    async def _execute_rebalance_orders(self, rebalance_orders: List[Dict]):
        """
        æ‰§è¡ŒæµåŠ¨æ€§å†å¹³è¡¡è®¢å•
        
        Args:
            rebalance_orders: å†å¹³è¡¡è®¢å•åˆ—è¡¨
        """
        try:
            current_time = int(time.time())
            
            for rebalance_order in rebalance_orders:
                order_id = f"rebalance_{rebalance_order['side'].lower()}_{current_time}_{self.metrics['orders_created']}"
                
                # åˆ›å»ºè®¢å•è¯·æ±‚
                order_request = OrderRequest(
                    order_id=order_id,
                    symbol="DOGEUSDT",
                    side=rebalance_order['side'],
                    qty=Decimal(str(rebalance_order['qty'])),
                    price=Decimal(str(rebalance_order['price']))
                )
                
                # é€šè¿‡è®¢å•æ‰§è¡Œå¼•æ“æäº¤ï¼ˆåŒ…å«é¢„æ‰£+é—­ç¯å¤„ç†ï¼‰
                success = await self.submit_order(order_request)
                if success:
                    self.metrics['orders_created'] += 1
                    logger.info(
                        "[WorldClassMaker] ğŸ”„ å†å¹³è¡¡è®¢å•: %s %s@%s order_id=%s",
                        rebalance_order['side'], rebalance_order['qty'], rebalance_order['price'], order_id
                    )
                else:
                    logger.warning(
                        "[WorldClassMaker] ğŸš« å†å¹³è¡¡è®¢å•å¤±è´¥: %s %s@%s",
                        rebalance_order['side'], rebalance_order['qty'], rebalance_order['price']
                    )
                    
        except Exception as e:
            logger.error("[WorldClassMaker] æ‰§è¡Œå†å¹³è¡¡è®¢å•å¤±è´¥: %s", str(e))
    
    def calculate_smart_order_size(self) -> int:
        """è®¡ç®—æ™ºèƒ½è®¢å•é‡ - åŸºäºå¸‚åœºçŠ¶æ€åŠ¨æ€è°ƒæ•´"""
        size = float(self.base_order_size)
        
        # 1. åŸºäºä½™é¢çš„è°ƒæ•´
        doge_balance = float(self.reservation_model.get_available_balance('DOGE'))
        usdt_balance = float(self.reservation_model.get_available_balance('USDT'))
        
        if self.latest_ticker:
            current_price = float(self.latest_ticker.bid + self.latest_ticker.ask) / 2
            max_doge_size = doge_balance * 0.1  # æœ€å¤šç”¨10%çš„DOGE
            max_usdt_size = (usdt_balance / current_price) * 0.1 if current_price > 0 else 0
        else:
            max_doge_size = doge_balance * 0.1
            max_usdt_size = 50  # é»˜è®¤å€¼
        
        # 2. åŸºäºæˆäº¤ç‡çš„è°ƒæ•´
        if len(self.recent_fills) > 0:
            fill_rate = len(self.recent_fills) / max(1, self.metrics['orders_created'])
            if fill_rate > 0.3:  # æˆäº¤ç‡é«˜äº30%
                size *= 1.5
            elif fill_rate < 0.1:  # æˆäº¤ç‡ä½äº10%
                size *= 0.8
        
        # 3. åŸºäºæ—¶é—´çš„è°ƒæ•´
        import time
        current_time = time.time()
        if self.last_fill_time > 0:
            time_since_fill = current_time - self.last_fill_time
            if time_since_fill > 60:  # è¶…è¿‡60ç§’æ— æˆäº¤
                size *= 0.7
            elif time_since_fill < 10:  # 10ç§’å†…æœ‰æˆäº¤
                size *= 1.3
        
        # 4. åŸºäºæ³¢åŠ¨ç‡çš„è°ƒæ•´
        if self.market_volatility > 0.005:  # é«˜æ³¢åŠ¨
            size *= 0.8
        elif self.market_volatility < 0.001:  # ä½æ³¢åŠ¨
            size *= 1.2
        
        # 5. é™åˆ¶èŒƒå›´
        size = max(20, min(size, 200))  # 20-200 DOGEèŒƒå›´
        size = min(size, max_doge_size, max_usdt_size)
        
        return int(size)
    
    async def _generate_envelope_based_orders(self, liquidity_snapshot: Dict, mid: Decimal, spread: Decimal):
        """
        åŸºäºæµåŠ¨æ€§åŒ…ç»œ + æ™ºèƒ½ä¸‹å•ç³»ç»Ÿç”Ÿæˆä¸–ç•Œçº§è®¢å•
        
        Phase 6 Step 4: é›†æˆQPE + ä¸‰é‡ä¸Šé™ + å¾®æ‰¹æ»´çŒ + PriceGuard
        
        Args:
            liquidity_snapshot: æµåŠ¨æ€§åŒ…ç»œå¿«ç…§
            mid: ä¸­é—´ä»·
            spread: ä»·å·®
        """
        try:
            current_time = int(time.time())
            
            # åˆ›å»ºå¸‚åœºå¿«ç…§ä¾›æ™ºèƒ½ä¸‹å•ç³»ç»Ÿä½¿ç”¨
            market_snapshot = MarketSnapshot(
                bid=mid - spread / Decimal('2'),
                ask=mid + spread / Decimal('2'),
                mid=mid,
                spread=spread,
                spread_bps=float((spread / mid) * Decimal('10000')),
                bid_size=Decimal('200'),  # ä¼°ç®—å€¼
                ask_size=Decimal('200'),  # ä¼°ç®—å€¼
                last_trade_time=current_time,
                last_trade_size=Decimal(str(self.calculate_smart_order_size()))
            )
            
            # æ›´æ–°æ™ºèƒ½ä¸‹å•ç³»ç»Ÿçš„å¸‚åœºæ•°æ®
            self.smart_order_system.update_market_data(market_snapshot)
            
            # ä»æµåŠ¨æ€§å¿«ç…§è·å–ç›®æ ‡é…ç½®
            buy_target = liquidity_snapshot.buy_side
            sell_target = liquidity_snapshot.sell_side
            
            # Phase 6 Step 4: ä½¿ç”¨æ™ºèƒ½ä¸‹å•ç³»ç»Ÿç”Ÿæˆä¹°å•
            l0_buy_slots = min(buy_target.l0_slots, 15)  # 8-15æ§½ä½
            for i in range(l0_buy_slots):
                # L0çº§åˆ«ç›®æ ‡ä»·æ ¼
                price_offset = (Decimal('1') + Decimal(str(i)) * Decimal('0.2')) * spread / Decimal('2')
                target_price = mid - price_offset
                
                # ç›®æ ‡æ•°é‡ (åŸºäºæµåŠ¨æ€§åŒ…ç»œ)
                total_notional = buy_target.target_notional
                # ä½¿ç”¨æ™ºèƒ½è®¢å•é‡
                smart_size = Decimal(str(self.calculate_smart_order_size()))
                base_qty = total_notional / (Decimal(str(l0_buy_slots)) * target_price) if total_notional > 0 else Decimal('0')
                target_qty = min(base_qty, smart_size)  # ä½¿ç”¨æ™ºèƒ½è®¢å•é‡ä½œä¸ºä¸Šé™
                
                if target_qty >= Decimal('20'):  # æœ€å°äº¤æ˜“é‡é˜ˆå€¼
                    # ä½¿ç”¨æ™ºèƒ½ä¸‹å•ç³»ç»Ÿç”Ÿæˆå¾®æ‰¹è®¢å•
                    smart_orders = self.smart_order_system.generate_smart_orders(
                        target_qty=target_qty,
                        level=SmartOrderLevel.L0,
                        side='BUY',
                        target_price=target_price,
                        market=market_snapshot
                    )
                    
                    # æ‰§è¡Œæ™ºèƒ½è®¢å•
                    for smart_order in smart_orders:
                        buy_feasible, _ = self.reservation_model.check_order_feasible(
                            'BUY', smart_order.qty, smart_order.price
                        )
                        
                        if buy_feasible:
                            order_id = f"smart_buy_L0_{i}_{current_time}_{self.metrics['orders_created']}"
                            
                            # åˆ›å»ºè®¢å•è¯·æ±‚
                            order_request = OrderRequest(
                                order_id=order_id,
                                symbol="DOGEUSDT",
                                side='BUY',
                                qty=smart_order.qty,
                                price=smart_order.price
                            )
                            
                            # Phase 6 Step 5: é€šè¿‡æ¯«ç§’å“åº”ç³»ç»Ÿæ³¨å†ŒCREATEäº‹ä»¶
                            def create_callback(event):
                                return self.submit_order(order_request)
                            
                            self.millisecond_response.register_create_event(
                                order_id=order_id,
                                side='BUY',
                                qty=smart_order.qty,
                                price=smart_order.price,
                                level=ResponseOrderLevel.L0,
                                callback=create_callback
                            )
                            
                            self.metrics['orders_created'] += 1
                            logger.debug(
                                "[WorldClassMaker] ğŸ¯ Smart Buy L0-%d: price=%s qty=%s (%s) [æ¯«ç§’å“åº”ç³»ç»Ÿ]", 
                                i, smart_order.price, smart_order.qty, smart_order.rationale[:20]
                            )
            
            # Phase 6 Step 4: ä½¿ç”¨æ™ºèƒ½ä¸‹å•ç³»ç»Ÿç”Ÿæˆå–å•
            l0_sell_slots = min(sell_target.l0_slots, 15)  # 8-15æ§½ä½
            for i in range(l0_sell_slots):
                # L0çº§åˆ«ç›®æ ‡ä»·æ ¼
                price_offset = (Decimal('1') + Decimal(str(i)) * Decimal('0.2')) * spread / Decimal('2')
                target_price = mid + price_offset
                
                # ç›®æ ‡æ•°é‡ (åŸºäºæµåŠ¨æ€§åŒ…ç»œ)
                total_notional = sell_target.target_notional
                # ä½¿ç”¨æ™ºèƒ½è®¢å•é‡
                smart_size = Decimal(str(self.calculate_smart_order_size()))
                base_qty = total_notional / target_price if total_notional > 0 else Decimal('0')
                target_qty = min(base_qty, smart_size)  # ä½¿ç”¨æ™ºèƒ½è®¢å•é‡ä½œä¸ºä¸Šé™
                
                if target_qty >= Decimal('20'):  # æœ€å°äº¤æ˜“é‡é˜ˆå€¼
                    # ä½¿ç”¨æ™ºèƒ½ä¸‹å•ç³»ç»Ÿç”Ÿæˆå¾®æ‰¹è®¢å•
                    smart_orders = self.smart_order_system.generate_smart_orders(
                        target_qty=target_qty,
                        level=SmartOrderLevel.L0,
                        side='SELL',
                        target_price=target_price,
                        market=market_snapshot
                    )
                    
                    # æ‰§è¡Œæ™ºèƒ½è®¢å•
                    for smart_order in smart_orders:
                        sell_feasible, _ = self.reservation_model.check_order_feasible(
                            'SELL', smart_order.qty, smart_order.price
                        )
                        
                        if sell_feasible:
                            order_id = f"smart_sell_L0_{i}_{current_time}_{self.metrics['orders_created']}"
                            
                            # åˆ›å»ºè®¢å•è¯·æ±‚
                            order_request = OrderRequest(
                                order_id=order_id,
                                symbol="DOGEUSDT",
                                side='SELL',
                                qty=smart_order.qty,
                                price=smart_order.price
                            )
                            
                            # Phase 6 Step 5: é€šè¿‡æ¯«ç§’å“åº”ç³»ç»Ÿæ³¨å†ŒCREATEäº‹ä»¶
                            def create_callback(event):
                                return self.submit_order(order_request)
                            
                            self.millisecond_response.register_create_event(
                                order_id=order_id,
                                side='SELL',
                                qty=smart_order.qty,
                                price=smart_order.price,
                                level=ResponseOrderLevel.L0,
                                callback=create_callback
                            )
                            
                            self.metrics['orders_created'] += 1
                            logger.debug(
                                "[WorldClassMaker] ğŸ¯ Smart Sell L0-%d: price=%s qty=%s (%s) [æ¯«ç§’å“åº”ç³»ç»Ÿ]", 
                                i, smart_order.price, smart_order.qty, smart_order.rationale[:20]
                            )
            
            # Phase 6 Step 4: è¾“å‡ºæ™ºèƒ½ä¸‹å•ç³»ç»ŸæŒ‡æ ‡
            smart_metrics = self.smart_order_system.get_system_metrics()
            logger.info(
                "[WorldClassMaker-SmartOrder] Generated=%d QPEEst=%d PriceAdj=%d SizeRed=%d TypicalSize=%.1f",
                smart_metrics['metrics']['orders_generated'],
                smart_metrics['metrics']['queue_estimates'],
                smart_metrics['metrics']['price_adjustments'],
                smart_metrics['metrics']['size_reductions'],
                smart_metrics['typical_size']
            )
                            
        except Exception as e:
            logger.error("[WorldClassMaker] åŸºäºæµåŠ¨æ€§åŒ…ç»œç”Ÿæˆè®¢å•å¤±è´¥: %s", str(e))
    
    def update_normalizer_coverage(self, event_processed: bool = True):
        """
        æ›´æ–°EventNormalizerè¦†ç›–ç‡æŒ‡æ ‡
        
        Args:
            event_processed: äº‹ä»¶æ˜¯å¦æˆåŠŸé€šè¿‡normalizerå¤„ç†
        """
        global NORMALIZER_COVERAGE
        
        self.total_events += 1
        if event_processed and HAVE_NORMALIZER:
            self.normalized_events += 1
            self.metrics['normalizer_events_processed'] += 1
        else:
            self.metrics['normalizer_events_fallback'] += 1
            
        # è®¡ç®—è¦†ç›–ç‡
        if self.total_events > 0:
            coverage = self.normalized_events / self.total_events
            self.metrics['normalizer_coverage'] = coverage * 100.0
            NORMALIZER_COVERAGE = coverage * 100.0
            
            # æ¯100ä¸ªäº‹ä»¶æŠ¥å‘Šä¸€æ¬¡è¦†ç›–ç‡
            if self.total_events % 100 == 0:
                logger.info(
                    "[WorldClassMaker] EventNormalizerè¦†ç›–ç‡: %.1f%% (%d/%d events)",
                    coverage * 100, self.normalized_events, self.total_events
                )
    
    async def run_world_class_maker(self):
        """è¿è¡Œä¸–ç•Œçº§åšå¸‚å•†"""
        self.running = True
        self.start_time = time.time()
        
        logger.info("[WorldClassMaker] ğŸš€ å¯åŠ¨ä¸–ç•Œçº§åšå¸‚å•†ç³»ç»Ÿ")
        
        try:
            # ä¸»è¿è¡Œå¾ªç¯
            while self.running:
                # æ›´æ–°è¿è¡Œæ—¶é—´
                self.metrics['runtime_seconds'] = time.time() - self.start_time
                
                # å®šæœŸè¾“å‡ºä»ªè¡¨æ¿
                if int(self.metrics['runtime_seconds']) % 10 == 0:  # æ¯10ç§’
                    self._emit_dashboard()
                
                # å®šæœŸæ¸…ç†åƒµå°¸è®¢å•ï¼ˆæ¯30ç§’ï¼‰
                await self.cleanup_zombie_orders()
                
                # é«˜é¢‘å¾ªç¯
                await asyncio.sleep(0.001)  # 1mså¾ªç¯
                
        except KeyboardInterrupt:
            logger.info("[WorldClassMaker] æ”¶åˆ°åœæ­¢ä¿¡å·")
        except Exception as e:
            logger.error("[WorldClassMaker] è¿è¡Œæ—¶é”™è¯¯: %s", str(e))
        finally:
            await self._shutdown()
    
    def _emit_dashboard(self):
        """è¾“å‡ºå®æ—¶ä»ªè¡¨æ¿"""
        # è·å–è®¢å•å¼•æ“çœŸå®ç»Ÿè®¡æ•°æ®
        order_engine_stats = self.order_engine.get_engine_stats()
        engine_stats = order_engine_stats['stats']
        
        # è®¡ç®—çœŸå®æˆäº¤ç‡
        total_orders = engine_stats.get('orders_submitted', 0)
        filled_orders = engine_stats.get('orders_filled', 0)
        fill_rate = (filled_orders / max(1, total_orders) * 100) if total_orders > 0 else 0
        
        # è®¡ç®—-2010é”™è¯¯ç‡ 
        reject_orders = engine_stats.get('orders_rejected', 0)
        error_rate = (reject_orders / max(1, total_orders) * 100) if total_orders > 0 else 0
        
        dashboard = {
            'ğŸ¯ è¿è¡Œæ—¶é—´': f"{self.metrics['runtime_seconds']:.0f}s",
            'âš¡ Tickerå¤„ç†': f"{self.metrics['tickers_processed']}",
            'ğŸ“Š è®¢å•åˆ›å»º': f"{self.metrics['orders_created']}",
            'ğŸ’° DOGEä½™é¢': f"{self.metrics['current_balance_doge']:.1f}",
            'ğŸ’° USDTä½™é¢': f"{self.metrics['current_balance_usdt']:.2f}",
            'â±ï¸ å¹³å‡å»¶è¿Ÿ': f"{self.metrics['avg_latency_ms']:.1f}ms",
            'ğŸ”„ æˆäº¤ç‡': f"{fill_rate:.1f}%",
            'âš ï¸ -2010é”™è¯¯ç‡': f"{error_rate:.1f}%"
        }
        
        logger.info("[WorldClassMaker-Dashboard] %s", dashboard)
        
        # è¾“å‡ºç³»ç»ŸçŠ¶æ€
        market_status = self.market_data.get_status()
        reservation_status = self.reservation_model.get_reservation_status()
        closed_loop_health = self.reservation_closed_loop.get_system_health()
        order_engine_stats = self.order_engine.get_engine_stats()
        
        logger.info(
            "[WorldClassMaker-Status] MarketData(active=%s switches=%d) "
            "Reservations(active=%d DOGE_avail=%s USDT_avail=%s)",
            market_status['active_source'],
            market_status['switch_count'], 
            reservation_status['active_reservations'],
            reservation_status['balances'].get('DOGE', {}).get('available', 0),
            reservation_status['balances'].get('USDT', {}).get('available', 0)
        )
        
        # Phase 6 æ­¥éª¤2: SSOTé¢„æ‰£é—­ç¯å¥åº·çŠ¶æ€
        logger.info(
            "[WorldClassMaker-SSOTClosedLoop] Active=%d Unreleased=%d RejectRate=%.2f%% Target=%s",
            closed_loop_health['active_orders'],
            closed_loop_health['unreleased_reservations'],
            closed_loop_health['reserve_reject_rate'],
            "âœ…" if closed_loop_health['target_achieved'] else "âŒ"
        )
        
        # è®¢å•å¼•æ“ç»Ÿè®¡
        stats = order_engine_stats['stats']
        logger.info(
            "[WorldClassMaker-OrderEngine] Submit=%d ACK=%d REJECT=%d FILL=%d CANCEL=%d TIMEOUT=%d",
            stats['orders_submitted'],
            stats['orders_acked'],
            stats['orders_rejected'],
            stats['orders_filled'],
            stats['orders_canceled'],
            stats['orders_timeout']
        )
        
        # Phase 6 æ­¥éª¤4: æ™ºèƒ½ä¸‹å•ç³»ç»Ÿç»Ÿè®¡
        smart_metrics = self.smart_order_system.get_system_metrics()
        logger.info(
            "[WorldClassMaker-SmartOrder] Generated=%d QPEEst=%d PriceAdj=%d SizeRed=%d TypicalSize=%.1f",
            smart_metrics['metrics']['orders_generated'],
            smart_metrics['metrics']['queue_estimates'],
            smart_metrics['metrics']['price_adjustments'],
            smart_metrics['metrics']['size_reductions'],
            smart_metrics['typical_size']
        )
        
        # Phase 6 æ­¥éª¤5: æ¯«ç§’å“åº”ç³»ç»Ÿç»Ÿè®¡
        response_metrics = self.millisecond_response.get_response_metrics()
        logger.info(
            "[WorldClassMaker-MillisecondResponse] Fillâ†’Repost_p99=%.1fms TTLViolations=%d QueueSize=%.1f ActiveOrders=%d",
            response_metrics['fill_to_repost_p99'],
            response_metrics['ttl_violations'],
            response_metrics['avg_queue_size'],
            response_metrics['active_orders']
        )
        
        # Phase 6 æ­¥éª¤7: å¯è§‚æµ‹æ€§ä»ªè¡¨ç›˜ç»Ÿè®¡ (8é¡¹æ ¸å¿ƒæŒ‡æ ‡)
        # æ›´æ–°ä»ªè¡¨ç›˜æŒ‡æ ‡
        try:
            # ç¡®ä¿æœ‰tickeræ•°æ®
            if self.latest_ticker is None:
                # å¦‚æœè¿˜æ²¡æœ‰tickeræ•°æ®ï¼Œå…ˆè·³è¿‡ä»ªè¡¨ç›˜æ›´æ–°
                return
                
            # æŒ‡æ ‡1: æˆäº¤å“åº”å»¶è¿ŸP99
            self.dashboard.update_fill_latency(response_metrics['fill_to_repost_p99'])
            
            # æŒ‡æ ‡2: è®¢å•æˆåŠŸç‡ (åŸºäºç³»ç»Ÿç»Ÿè®¡)
            total_orders = self.metrics['orders_created']
            success_orders = total_orders  # æ¨¡æ‹Ÿï¼šç›®å‰ç³»ç»Ÿè®¢å•æˆåŠŸç‡100%
            self.dashboard.update_order_success_rate(success_orders, max(1, total_orders))
            
            # æŒ‡æ ‡3: åº“å­˜åæ–œæ¯”ç‡
            doge_balance = self.reservation_model.get_available_balance('DOGE')
            usdt_balance = self.reservation_model.get_available_balance('USDT')
            current_price = (self.latest_ticker.bid + self.latest_ticker.ask) / 2  # ä½¿ç”¨ä¸­é—´ä»·
            total_capital = usdt_balance + doge_balance * current_price
            target_inventory = total_capital * Decimal('0.5')  # ç›®æ ‡50/50åˆ†é…
            current_inventory = doge_balance * current_price
            self.dashboard.update_inventory_skew(current_inventory, target_inventory, total_capital)
            
            # æŒ‡æ ‡4: ä»·å·®æ•è·æ•ˆç‡ (åŸºäºå®é™…æˆäº¤)
            theoretical_spread = (self.latest_ticker.ask - self.latest_ticker.bid) * Decimal('0.8')  # 80%ç†è®ºæ•è·
            actual_spread = Decimal('0.0002')  # æ¨¡æ‹Ÿå®é™…æ•è·ä»·å·®
            self.dashboard.update_spread_capture(actual_spread, theoretical_spread)
            
            # æŒ‡æ ‡5: æµåŠ¨æ€§ä¾›ç»™è¯„åˆ†
            bid_depth = doge_balance * Decimal('0.1')  # 10%ä½œä¸ºæ·±åº¦
            ask_depth = usdt_balance / current_price * Decimal('0.1')
            market_impact = 0.001  # æ¨¡æ‹Ÿå¸‚åœºå½±å“
            uptime_ratio = min(1.0, self.metrics['runtime_seconds'] / 3600)  # åŸºäºè¿è¡Œæ—¶é—´
            self.dashboard.update_liquidity_score(bid_depth, ask_depth, market_impact, uptime_ratio)
            
            # æŒ‡æ ‡6: é£é™©åŠ æƒæ•å£
            position_value = abs(doge_balance * current_price - usdt_balance)
            var_estimate = position_value * Decimal('0.02')  # 2% VaRä¼°è®¡
            self.dashboard.update_risk_exposure(position_value, var_estimate)
            
            # æŒ‡æ ‡7: APIæƒé‡ä½¿ç”¨ç‡ (æ¨¡æ‹Ÿ)
            current_weight = 150  # æ¨¡æ‹Ÿå½“å‰APIæƒé‡
            max_weight = 1200     # Binanceç°è´§APIæƒé‡ä¸Šé™
            self.dashboard.update_api_utilization(current_weight, max_weight)
            
            # æ›´æ–°æŒ‡æ ‡å¿«ç…§å¹¶æ£€æŸ¥ä¿æŠ¤ç­–ç•¥
            self.dashboard.update_metrics_snapshot()
            
            # è·å–ä»ªè¡¨ç›˜æ‘˜è¦
            dashboard_summary = self.dashboard.get_dashboard_summary()
            alert_level = dashboard_summary['alert_level']
            
            logger.info(
                "[WorldClassMaker-Dashboard] ğŸ¯ AlertLevel=%s HealthScore=%.2f LatencyP99=%.1fms Success=%.1f%% Skew=%.1f%% APIUse=%.1f%%",
                alert_level,
                dashboard_summary['metrics']['ç³»ç»Ÿå¥åº·åº¦è¯„åˆ†'],
                dashboard_summary['metrics']['æˆäº¤å“åº”å»¶è¿ŸP99(ms)'],
                dashboard_summary['metrics']['è®¢å•æˆåŠŸç‡(%)'],
                dashboard_summary['metrics']['åº“å­˜åæ–œæ¯”ç‡(%)'],
                dashboard_summary['metrics']['APIæƒé‡ä½¿ç”¨ç‡(%)']
            )
            
            # ä¿æŠ¤ç­–ç•¥çŠ¶æ€
            if self.dashboard.protection_active:
                logger.warning(
                    "[WorldClassMaker-Dashboard] âš ï¸  è‡ªä¿æŠ¤ç­–ç•¥å·²æ¿€æ´»: %s (æŒç»­%.1fs)",
                    self.dashboard.protection_reason,
                    time.time() - self.dashboard.protection_start_time
                )
                
        except Exception as e:
            logger.error("[WorldClassMaker-Dashboard] ä»ªè¡¨ç›˜æ›´æ–°å¤±è´¥: %s", str(e))
        
        # Phase 6 æ­¥éª¤6: åº“å­˜ç®¡ç†ä¸‰æ—¶åŸŸç³»ç»Ÿç»Ÿè®¡
        inventory_metrics = self.inventory_system.get_system_metrics()
        logger.info(
            "[WorldClassMaker-InventorySystem] æ¯«ç§’å“åº”=%d ç§’çº§è°ƒæ•´=%d åˆ†é’ŸTWAP=%d ç´§æ€¥å¹²é¢„=%d ç³»ç»Ÿå¥åº·=%s",
            inventory_metrics['domain_responses']['millisecond_responses'],
            inventory_metrics['domain_responses']['second_adjustments'],
            inventory_metrics['domain_responses']['minute_twaps'],
            inventory_metrics['domain_responses']['emergency_interventions'],
            inventory_metrics['system_health']
        )
    
    async def _shutdown(self):
        """ä¼˜é›…å…³é—­"""
        self.running = False
        
        try:
            # å…ˆæ’¤é”€æ‰€æœ‰æ´»è·ƒè®¢å•
            await self.cancel_all_orders()
            
            # å…³é—­æ¯«ç§’å“åº”ç³»ç»Ÿ
            await self.millisecond_response.stop()
            
            # å…³é—­è®¢å•å¼•æ“
            await self.order_engine.shutdown()
            
            # å¼ºåˆ¶é‡Šæ”¾æ‰€æœ‰æœªé‡Šæ”¾çš„é¢„æ‰£
            unreleased = self.reservation_closed_loop.force_release_all_reservations()
            if unreleased > 0:
                logger.warning("[WorldClassMaker] å¼ºåˆ¶é‡Šæ”¾äº† %d ä¸ªæœªé‡Šæ”¾çš„é¢„æ‰£", unreleased)
            
            # åœæ­¢å¸‚åœºæ•°æ®
            await self.market_data.stop()
            
            # è¾“å‡ºæœ€ç»ˆç»Ÿè®¡
            logger.info(
                "[WorldClassMaker] ğŸ è¿è¡Œç»“æŸ: è¿è¡Œæ—¶é•¿=%ds Tickers=%d è®¢å•=%d",
                int(self.metrics['runtime_seconds']),
                self.metrics['tickers_processed'],
                self.metrics['orders_created']
            )
            
            # è¾“å‡ºSSOTé¢„æ‰£é—­ç¯æœ€ç»ˆçŠ¶æ€
            final_health = self.reservation_closed_loop.get_system_health()
            logger.info(
                "[WorldClassMaker] SSOTé—­ç¯æœ€ç»ˆçŠ¶æ€: RejectRate=%.2f%% Target=%s",
                final_health['reserve_reject_rate'],
                "âœ…è¾¾æ ‡" if final_health['target_achieved'] else "âŒæœªè¾¾æ ‡"
            )
            
            # è¾“å‡ºè´¦æœ¬çŠ¶æ€
            ledger_status = self.event_ledger.get_ledger_status()
            logger.info(
                "[WorldClassMaker] è´¦æœ¬çŠ¶æ€: äº‹ä»¶=%d ä½™é¢(DOGE=%s USDT=%s)",
                ledger_status['events_in_ledger'],
                ledger_status['current_balance']['base'],
                ledger_status['current_balance']['quote']
            )
            
        except Exception as e:
            logger.error("[WorldClassMaker] å…³é—­æ—¶é”™è¯¯: %s", str(e))


async def main():
    """ä¸»å‡½æ•°"""
    # æ£€æŸ¥ç¯å¢ƒå˜é‡
    if os.getenv('DRY_RUN') == '1':
        logger.warning("[WorldClassMaker] DRY_RUNæ¨¡å¼ï¼Œä»…æ¨¡æ‹Ÿè¿è¡Œ")
    else:
        logger.info("[WorldClassMaker] çœŸå®èµ„é‡‘æ¨¡å¼")
    
    # åˆ›å»ºä¸–ç•Œçº§åšå¸‚å•†
    maker = WorldClassMarketMaker()
    
    # åˆå§‹åŒ–ç»„ä»¶
    if not await maker.initialize_components():
        logger.error("[WorldClassMaker] åˆå§‹åŒ–å¤±è´¥ï¼Œé€€å‡º")
        return 1
    
    # è¿è¡Œåšå¸‚å•†
    await maker.run_world_class_maker()
    
    return 0


if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except Exception as e:
        logger.error("[WorldClassMaker] è‡´å‘½é”™è¯¯: %s", str(e), exc_info=True)
        sys.exit(1)